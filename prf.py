# -*- coding: utf-8 -*-
"""prf.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WIxm0Y2Df8twXvy5qPrHIiAy0PQ1HPyG
"""

!pip install qiskit qiskit_aer
!pip install qiskit_ibm_runtime

import qiskit
print(qiskit.__version__)

import math
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit_aer import AerSimulator
from qiskit import transpile
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler

import hmac
import hashlib


def hmac_prf(secret_key, input_data):
    """
    Generate HMAC using SHA-256 and return the binary output (256 bits).

    Args:
    - secret_key (str): Shared secret key (K).
    - input_data (str): Previous value and identifier for PRF.

    Returns:
    - str: 256-bit binary output from the HMAC function.
    """
    hmac_output = hmac.new(
        secret_key.encode(), input_data.encode(), hashlib.sha256
    ).hexdigest()
    return bin(int(hmac_output, 16))[2:].zfill(256)[:28]


def generate_new_key(K, seed, round_number):
    """
    Generate a new key using HMAC and expand using the previous key (T1, T2, T3, ...).

    Args:
    - K (str): Shared secret key (K).
    - seed (str): A unique seed (e.g., for each QKD round).
    - round_number (int): The round number, used to create unique identifiers (0x01, 0x02, ...).

    Returns:
    - str: A new key derived from K using HMAC-based PRF.
    """
    # Construct identifier (e.g., 0x01, 0x02, ...)
    identifier = f"0x{round_number:02X}"

    # Combine the previous output with the seed and identifier for HMAC input
    input_data = f"{K}|{seed}|{identifier}"

    # Get the next key (T1, T2, ...)
    return hmac_prf(K, input_data)

# Shared Key (K) and Initial Seed (S)
shared_key = "shared_secret_key"  # Shared secret key (K)
seed = "shared_seed"  # Shared seed (S)

# Generate multiple keys (T1, T2, T3, ...) based on shared key (K) and seed (S)
rounds = 5 # Example: number of rounds you want to generate keys for

keys = []
for round_number in range(1, rounds + 1):
    new_key = generate_new_key(shared_key, seed, round_number)
    keys.append(new_key)
    print(f"T{round_number} = {new_key}")  # Display each generated key

keys[0]

alice_bases = keys[0]
bob_bases = keys[0]

"""# Real Hardware"""

token= "90c11c3427d32b9170daa73f5fffe26dc68634b8b6f0d8e5a83082726bd42c2d384e16c5ea3f3ed03f5cb71156de8fb4ba9b3880f9f990c6ed2d275f315de5d3"
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler
from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

QiskitRuntimeService.save_account(
  token=token,
  channel="ibm_quantum",
  overwrite=True
)

service = QiskitRuntimeService()
n_qubits = 5
backend = service.least_busy(operational=True, simulator=False, min_num_qubits=n_qubits)
print("Selected Backend", backend)

# Function to generate a random binary string using quantum circuits
def RandomStringIBM(str_len):
    op_str = ''  # Initialize an empty output string
    num_qbits = 10  # Define number of qubits

    # Calculate the number of chunks needed
    num_chunks = math.ceil(str_len / num_qbits)
    for _ in range(num_chunks):
        # Create a quantum register and a classical register
        q = QuantumRegister(num_qbits)
        c = ClassicalRegister(num_qbits)
        QC = QuantumCircuit(q, c)

        # Apply Hadamard gates to all qubits to create superposition
        for i in range(num_qbits):
            QC.h(q[i])
        QC.measure(q, c)
        pm = generate_preset_pass_manager(backend=backend, optimization_level=1)
        isa_circuit = pm.run(QC)

        sampler = Sampler(backend)
        job = sampler.run([isa_circuit])
        result = job.result()

len_message = 10
alice_key = RandomStringIBM(len_message)

from qiskit_ibm_runtime import QiskitRuntimeService
job = service.job('cy3rmfscw2k0008jmtrg')
result = job.result()

data = result[0].data
bitarray = next(iter(data.values()))
counts = bitarray.get_counts()

# Calculate the sum of counts
total_shots = sum(counts.values())
print("Total measurements (sum):", total_shots)

first_bitstring = next(iter(counts.keys()))
print(first_bitstring)

print(counts)

"""# Simulation"""

# Function to generate a random binary string using quantum circuits
def RandomString(str_len):
    op_str = ''  # Initialize an empty output string
    num_qbits = 10  # Define number of qubits

    # Calculate the number of chunks needed
    num_chunks = math.ceil(str_len / num_qbits)
    for _ in range(num_chunks):
        # Create a quantum register and a classical register
        q = QuantumRegister(num_qbits)
        c = ClassicalRegister(num_qbits)
        QC = QuantumCircuit(q, c)

        # Apply Hadamard gates to all qubits to create superposition
        for i in range(num_qbits):
            QC.h(q[i])
        QC.measure(q, c)

        simulator = AerSimulator()
        # Measure the qubits
        circ = transpile(QC, simulator)
        result = simulator.run(circ, shots=1, memory=True).result()
        memory = result.get_memory(circ)
        op_str += memory[0]  # Append the measured result to op_str

    return op_str[:str_len]  # Return the full random string

len_message = 28
alice_key = RandomString(len_message)

# Quantum Circuit for encoding
q = QuantumRegister(len_message)
c = ClassicalRegister(len_message)
qc = QuantumCircuit(q, c)

# Encode qubits based on Alice's key and basis
for i in range(len_message):
    if alice_key[i] == '1':
        qc.x(q[i])  # Flip the qubit to 1 if key is 1
    if alice_bases[i] == '1':

        qc.h(q[i])  # Apply Hadamard gate if basis is 1
qc.barrier()

qc.draw()

# Step 3: Bob measures the qubits
for i in range(len_message):
    if bob_bases[i] == '1':
        qc.h(q[i])  # Bob applies Hadamard if measuring in Hadamard basis

# Add measurements
qc.measure(q, c)

# Run the circuit
simulator = AerSimulator()
circ = transpile(qc, simulator)
result = simulator.run(circ, shots=1, memory=True).result()
bob_result = result.get_memory(circ)
print('Bob Measurement Result:', bob_result[0])

# Display matching bits for shared key
shared_key = []
for i in range(len_message):
    if alice_bases[i] == bob_bases[i]:  # Only keep the bit if bases match
        shared_key.append(bob_result[0][len_message - i - 1])  # Reverse order in Qiskit

final_shared_key = ''.join(shared_key)
print('Final Shared Key:', final_shared_key)

# Calculate the percentage of key bits retained
matching_bits_count = len(final_shared_key)
percentage_retained = (matching_bits_count / len_message) * 100
print("Percentage of key bits retained: ", percentage_retained, "%")

"""Job id = 773e84cb-4b67-405e-8383-9bdeed4124e8"""

len(final_shared_key)

import random

# Function to convert a string to binary
def text_to_bin(text):
    return ''.join(format(ord(c), '08b') for c in text)

# Function to convert binary back to string
def bin_to_text(binary_string):
    chars = [binary_string[i:i+8] for i in range(0, len(binary_string), 8)]
    return ''.join(chr(int(char, 2)) for char in chars)

# Function to encrypt a message using One-Time Pad
def encrypt(message, key):
    # Convert the message to binary
    binary_message = text_to_bin(message)

    # Encrypt by XORing the binary message with the key (key length fixed at 28)
    encrypted = ''.join(str(int(binary_message[i]) ^ int(key[i % len(key)])) for i in range(len(binary_message)))
    return encrypted

# Function to decrypt a message using One-Time Pad
def decrypt(ciphertext, key):
    # Decrypt by XORing the ciphertext with the key
    decrypted = ''.join(str(int(ciphertext[i]) ^ int(key[i % len(key)])) for i in range(len(ciphertext)))

    # Convert the decrypted binary string back to text
    return bin_to_text(decrypted)

# Example usage
message = "Helod World"

# Assuming final_shared_key is predefined and has a length of 28

print(f"Key: {final_shared_key}")

# Encrypt the message using One-Time Pad
ciphertext = encrypt(message, final_shared_key)
print(f"Encrypted Message (Binary): {ciphertext}")

# Decrypt the message using the same key
decrypted_message = decrypt(ciphertext, final_shared_key)
print(f"Decrypted Message: {decrypted_message}")

